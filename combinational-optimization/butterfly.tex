% !TEX program = lualatex
\documentclass[...]{ltjsarticle}
\usepackage{graphicx}
\usepackage{amsmath,ascmac}
\usepackage{bm}
\usepackage{algorithm}
\usepackage{listings}
\usepackage{subcaption}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{enumitem}
\usepackage{algpseudocode}
\usepackage{multirow}
\usepackage{graphicx}
\usepackage{makecell}
\usepackage{booktabs}
\lstdefinelanguage{Julia}%
  {morekeywords={abstract,break,case,catch,const,continue,do,else,elseif,end,export,false,for,function,immutable,import,importall,if,in,macro,module,quote,return,struct,true,try,type,typealias,using,while},%
   sensitive=true,%
   morecomment=[l]{\#},%      % # を \# に修正
   morecomment=[s]{\#=}{=\#},% % # を \# に修正
   morestring=[b]",%
   morestring=[m]'%
  }
\lstset{%
  language={Julia}, % Juliaをメインで使うならここを {Julia} にしてもOKです
  basicstyle={\small\ttfamily}, % 読みやすさのため ttfamily を推奨
  identifierstyle={\small},%
  commentstyle={\small\itshape},%
  keywordstyle={\small\bfseries},%
  ndkeywordstyle={\small},%
  stringstyle={\small\ttfamily},
  frame={tb},
  breaklines=true,
  columns=fullflexible, % [l] を外すとより安定します
  keepspaces=true, % スペースを維持
  numbers=left,%
  xrightmargin=0pt, % 0zw から 0pt に変更
  xleftmargin=3em,  % 3zw から 3em に変更（1zw ≒ 1em です）
  numberstyle={\scriptsize},%
  stepnumber=1,
  numbersep=1em,    % 1zw から 1em に変更
  lineskip=-0.5ex%
}
\renewcommand{\lstlistingname}{コード}
\renewcommand{\lstlistlistingname}{コード目次}
\renewcommand{\thesubsection}{(\arabic{subsection})}
\renewcommand{\thesection}{\arabic{section}}

\algrenewcommand\algorithmicif{\textbf{if}}
\algrenewcommand\algorithmicthen{\textbf{then}}
\algrenewcommand\algorithmicelse{\textbf{else}}
\algrenewcommand\algorithmicfor{\textbf{for}}
\algrenewcommand\algorithmicforall{\textbf{for each}}
\algrenewcommand\algorithmicdo{\textbf{do}}
\algrenewcommand\algorithmicwhile{\textbf{while}}
\algrenewcommand\algorithmicprocedure{\textbf{procedure}}
\algrenewcommand\algorithmicfunction{\textbf{function}}
\algnewcommand\algorithmicreturnvalue{\textbf{return}}
\algnewcommand\ReturnValue[1]{\State \algorithmicreturnvalue\ #1}
\algnewcommand\algorithmicoutput{\textbf{output}}
\algnewcommand\Output[1]{\State \algorithmicoutput\ #1}
\algrenewcommand\algorithmicend{\textbf{end}}
\algrenewcommand\algorithmicreturn{\textbf{return}}

\begin{document}

\begin{titlepage}
    \centering
    \vfill
    
    {\Huge 数理工学実験\par}
    \vspace{1cm}
    
    {\Large 組合せ最適化レポート\par}
    
    \vfill
    
    {\Large
    所属: 工学部情報学科数理工学コース2年\par
    学籍番号: 1029-36-1263\par
    氏名: 天野 塁\par
    }
    
    \vfill
    
    {\Large 提出日: \today \par}
    
    \vfill
\end{titlepage}


\section{課題1 最短路を求める分枝アルゴリズムの設計}
\label{sec:q1}
有効グラフ$G = (V, E)$, 節点$s,t \in V$及び各枝$(u,v) \in E$の重み$d(u,v)$が与えられたとき, 
点$s$から点$t$へ至る最短路を求める分枝アルゴリズムは, 
Algorithm \ref{algo:q1}の疑似コードの通り. 
現在のパスをに節点を1つ追加してパスを延長する関数FindShortestPathを, 
始点$s$から順に再帰呼び出しすることで深さ優先でグラフの探索を行っている. 
そして探索中に終点$t$にたどり着いたら, それが現時点での最短路であるかを判定している. 
これにより, グラフの$s$から$t$へ至る全てのパスを探索し, 
その中で枝重みの和が最も小さくなるパスを求めることができる. \\
ただし疑似コード中の$P$.push($v$)はパス$P$の最後尾に節点$v$を追加する操作を, 
$P$.pop()はパス$P$の最後尾の接点を削除する操作を表す. 


\begin{algorithm}
\caption{有効グラフの最短路を求める}
\label{algo:q1}
\begin{algorithmic}[1]
\State bestP := $\emptyset$
\State minWeight := $\infty$
\\
\Function{FindShortestPath}{$P, u,$ currentWeight}
  \State $P$.push($u$);
  \If{$u = t$}
    \If{currentWeight < minWeight}
      \State minWeight $:=$ currentWeight
      \State bestP $:= P$
    \EndIf
    \ReturnValue{bestP, minWeight}
  \Else
    \For{$(u,v) \in E ,\ v \notin P$}
      \State FindShortestPath($P, v, \text{currentWeight} + d(u, v)$)   
    \EndFor
  \EndIf
  \\
  \State $P$.pop()
  \ReturnValue{bestP, minWeight}
\EndFunction
\\
\State $P := \emptyset$
\State bestP, minWeight = FindShortestPath($P, s, 0$)
\Output{bestP, minWeight}
\end{algorithmic}
\end{algorithm}


\section{課題2 最短路問題の節点数及び枝数による計算コストの比較}
\label{sec:q2}
Algorithm \ref{algo:q1}を用いて, 
グラフの節点数を$5, 7, 9, 11, 13, 15$の6通り, 
枝の密度を$0.3, 0.5, 0.7, 0.9$の4通りに変化させて最短路問題を解いた. 
ただし枝の密度とは完全グラフの枝数に対する探索するグラフの枝数の割合で, 
完全グラフの枝数に密度を掛けた値が整数でない場合は切り捨て処理を行った. 
このときの枝数及び枝の密度と計算時間及び探索したノード数の関係は以下の表\ref{tab:q2-1}, \ref{tab:q2-2}の通り. 
ただし各セルの上段の値は5回の試行の平均値であり, 下段の括弧内の値は標準偏差である. 
またグラフは生成時に始点$s$から終点$t$へのパスが存在することを確認しているため, 
実行結果にはパスが存在しないものは含まれていない. \\
計算時間も探索したノード数も, 節点数及び枝の密度が多くなるほど増加しており, 
その増加割合は節点数及び枝の密度が多くなるほど大きくなっている. 
このことから組合せ爆発が起きていることが読み取れる. 
また標準偏差のオーダーが平均値以上になっているデータが多いため, 
試行回数が少ないことの影響もあるだろうが, 
計算コストがグラフの形状に依存しているという可能性もある. 


\begin{table}[htbp]
    \centering
    \caption{節点数及び枝の密度に対する計算時間[ms]}
    \label{tab:q2-1}
    \begin{tabular}{cccccc}
        \toprule
        & & \multicolumn{4}{c}{枝の密度} \\
        & & 0.3 & 0.5 & 0.7 & 0.9 \\
        \midrule
        \multirow{6}{*}{\rotatebox{90}{節点数[個]}} 
        & 5  & \makecell{0.0010 \\ ($\pm$ 0.0016)} & \makecell{0.0009 \\ ($\pm$ 0.0007)} & \makecell{0.0010 \\ ($\pm$ 0.0005)} & \makecell{0.0014 \\ ($\pm$ 0.0007)} \\ \addlinespace
        & 7  & \makecell{0.0008 \\ ($\pm$ 0.0002)} & \makecell{0.0014 \\ ($\pm$ 0.0004)} & \makecell{0.0026 \\ ($\pm$ 0.0008)} & \makecell{0.0038 \\ ($\pm$ 0.0024)} \\ \addlinespace
        & 9  & \makecell{0.0017 \\ ($\pm$ 0.0006)} & \makecell{0.0049 \\ ($\pm$ 0.0017)} & \makecell{0.1887 \\ ($\pm$ 0.1410)} & \makecell{0.1838 \\ ($\pm$ 0.3880)} \\ \addlinespace
        & 11 & \makecell{0.0092 \\ ($\pm$ 0.0066)} & \makecell{0.2293 \\ ($\pm$ 0.2911)} & \makecell{3.0450 \\ ($\pm$ 6.6555)} & \makecell{44.9794 \\ ($\pm$ 100.5398)} \\ \addlinespace
        & 13 & \makecell{0.0115 \\ ($\pm$ 0.0075)} & \makecell{0.1013 \\ ($\pm$ 0.1130)} & \makecell{5.0919 \\ ($\pm$ 6.6004)} & \makecell{8.4874 \\ ($\pm$ 15.7890)} \\ \addlinespace
        & 15 & \makecell{0.0638 \\ ($\pm$ 0.0934)} & \makecell{114.3663 \\ ($\pm$ 255.6798)} & \makecell{3.12 $\times 10^3$ \\ ($\pm$ 6.98 $\times 10^3$)} & \makecell{7.58 $\times 10^4$ \\ ($\pm$ 1.68 $\times 10^5$)} \\
        \bottomrule
    \end{tabular}
\end{table}

\begin{table}[htbp]
    \centering
    \caption{節点数及び枝の密度に対する探索したノード数[個]}
    \label{tab:q2-2}
    \begin{tabular}{cccccc}
        \toprule
        & & \multicolumn{4}{c}{枝の密度} \\
        & & 0.3 & 0.5 & 0.7 & 0.9 \\
        \midrule
        \multirow{6}{*}{\rotatebox{90}{節点数[個]}} 
        & 5  & \makecell{4.2 \\ ($\pm$ 1.30)} & \makecell{7.8 \\ ($\pm$ 0.84)} & \makecell{8.2 \\ ($\pm$ 3.27)} & \makecell{10.4 \\ ($\pm$ 2.51)} \\ \addlinespace
        & 7  & \makecell{9.6 \\ ($\pm$ 2.07)} & \makecell{14.0 \\ ($\pm$ 3.08)} & \makecell{16.6 \\ ($\pm$ 4.56)} & \makecell{19.8 \\ ($\pm$ 10.13)} \\ \addlinespace
        & 9  & \makecell{14.2 \\ ($\pm$ 4.55)} & \makecell{30.4 \\ ($\pm$ 14.83)} & \makecell{631.0 \\ ($\pm$ 526.92)} & \makecell{323.6 \\ ($\pm$ 650.61)} \\ \addlinespace
        & 11 & \makecell{56.6 \\ ($\pm$ 30.93)} & \makecell{794.8 \\ ($\pm$ 1040.32)} & \makecell{7322.4 \\ ($\pm$ 16178.95)} & \makecell{84916.6 \\ ($\pm$ 189793.76)} \\ \addlinespace
        & 13 & \makecell{57.8 \\ ($\pm$ 31.62)} & \makecell{253.4 \\ ($\pm$ 245.13)} & \makecell{8216.8 \\ ($\pm$ 10116.28)} & \makecell{11018.0 \\ ($\pm$ 20442.89)} \\ \addlinespace
        & 15 & \makecell{225.6 \\ ($\pm$ 288.03)} & \makecell{221535.0 \\ ($\pm$ 495253.28)} & \makecell{4.08 $\times 10^6$ \\ ($\pm$ 9.13 $\times 10^6$)} & \makecell{7.06 $\times 10^7$ \\ ($\pm$ 1.56 $\times 10^8$)} \\
        \bottomrule
    \end{tabular}
\end{table}


\clearpage
\section{課題3 効率よく最短路を求めるための限定操作アルゴリズムの設計}
\label{sec:q3}
\ref{sec:q1}のアルゴリズムでは節点数や枝の密度が増えたときに組合せ爆発が起こり, 
計算コストが著しく増加した. 
そのため本章では効率よく最短路を求めるため, 限定操作のアルゴリズムを設計した. 
設計したものはAlgorithm \ref{algo:q3-1}の疑似コードの通り. 
現在のパスを延長してできる任意のパスの重みは, 
現在のパスにつながっていない枝のうち重みが負のものを全て加えた値よりも大きくなる. 
つまり現在のパスを$P$, 現在の点を$p$, 現在のパスの重みを$w$とすると, 
そこから延長してできるパスの重みの下界値$b$は
\begin{align}
  b &= w + \sum_{(u,v) \in \hat{E}} d(u,v) \\
  \hat{E} &= \{ (u,v) \in E \ |\ 
  u \in V \backslash (P \backslash p),\ v \in V \backslash P,\ d(u,v) < 0 \}
\end{align}
となる. 
この下界値$b$が現在の最短路の重みである暫定値以上になれば, 
現在の最短路が更新されることはないため, それ以降の探索を打ち切る. \\
この限定操作を組み込んだ全体のアルゴリズムはAlgorithm \ref{algo:q3-2}の疑似コードの通り. 
限定操作によって探索を打ち切るかどうかの判定を, 新しく点を探索するたびに行っている. 
そして打ち切るとなった場合は現時点での最短路を更新せずにそのまま返している. 



\begin{algorithm}
\caption{現在のパスの下界値テスト}
\label{algo:q3-1}
\begin{algorithmic}[1]
\Function{IsBounded}{$P$, currentWeight, minWeight}
\State negativePaths := \{ $(u,v) \in E \ |\
u \in V \backslash P.\text{pop()} ,\ v \in V \backslash P,\ d(u,v) < 0$ \}
\State lowerBound $:=$ currentWeight
\For{np $\in$ negativePaths}
  \State  lowerBound += np.weight
\EndFor
\ReturnValue{lowerBound $\geq$ minWeight} \Comment{限定操作をするかをboolで返す}
\EndFunction
\end{algorithmic}
\end{algorithm}


\begin{algorithm}
\caption{限定操作を用いて有効グラフの最短路を効率的に求める}
\label{algo:q3-2}
\begin{algorithmic}[1]
\State bestP := $\emptyset$
\State minWeight := $\infty$
\\
\Function{FindShortestPath}{$P, u,$ currentWeight}
  \State $P$.push($u$);
  \If{IsBounded($P$, currentWeight, minWeight)} 
    \State $P$.pop();
    \ReturnValue{bestP, minWeight} \Comment{ここで探索を打ち切る}
  \EndIf
  \\
  \If{$u = t$}
    \If{currentWeight < minWeight}
      \State minWeight $:=$ currentWeight
      \State bestP $:= P$
    \EndIf
    \ReturnValue{bestP, minWeight}
  \Else
    \For{$(u,v) \in E ,\ v \notin P$}
      \State FindShortestPath($P, v, \text{currentWeight} + d(u, v)$)   
    \EndFor
  \EndIf
  \\
  \State $P$.pop()
  \ReturnValue{bestP, minWeight}
\EndFunction
\\
\Function{IsBounded}{$P$, currentWeight, minWeight}
\State negativePaths := \{ $(u,v) \in E \ |\
u \in V \backslash P.\text{pop()} ,\ v \in V \backslash P,\ d(u,v) < 0$ \}
\State lowerBound $:=$ currentWeight
\For{np $\in$ negativePaths}
  \State  lowerBound += np.weight
\EndFor
\ReturnValue{lowerBound $\geq$ minWeight} \Comment{限定操作をするかをboolで返す}
\EndFunction
\\
\State $P := \emptyset$
\State bestP, minWeight = FindShortestPath($P, s, 0$)
\Output{bestP, minWeight}
\end{algorithmic}
\end{algorithm}


\clearpage
\section{課題4 限定操作を取り入れた最短路問題の節点数及び枝数による計算コストの比較}
\label{sec:q4}
Algorithm \ref{algo:q3-2}を用いて, 
グラフの節点数を$5, 7, 9, 11, 13, 15$の6通り, 
枝の密度を$0.3, 0.5, 0.7, 0.9$の4通りに変化させて最短路問題を解いた. 
ただし枝の密度とは完全グラフの枝数に対する探索するグラフの枝数の割合で, 
完全グラフの枝数に密度を掛けた値が整数でない場合は切り捨て処理を行った. 
このときの枝数及び枝の密度と計算時間及び探索したノード数の関係は以下の表\ref{tab:q4-1}, \ref{tab:q4-2}の通り. 
ただし各セルの上段の値は5回の試行の平均値であり, 下段の括弧内の値は標準偏差である. 
またグラフは生成時に始点$s$から終点$t$へのパスが存在することを確認しているため, 
実行結果にはパスが存在しないものは含まれていない. \\
\ref{sec:q2}章と比較して, 計算時間も探索したノード数も, 
節点数及び枝の密度が多くなるほど増加しているという傾向は変わらない. 
しかし増加の割合は\ref{sec:q2}章よりも大幅に小さく抑えられている. 
特に節点数が$15$, 枝の密度が$0.9$の組合せ数が最大になる場合で, 
節点数も枝の密度も\ref{sec:q2}章と比較して$10^{-4}$倍ほどに抑えられている. 
このことから, Algorithm \ref{algo:q3-1}の限定操作は, 
組合せの数が増えるほど計算コスト削減に効果的に寄与しているといえる. 
また標準偏差のオーダーが平均値以上になっているデータが多いため, 
試行回数が少ないことの影響もあるだろうが, 
計算コストはグラフの形状や探索する順番に大きく依存するという可能性もある. 


\begin{table}[htbp]
    \centering
    \caption{節点数及び枝の密度に対する計算時間[ms]}
    \label{tab:q4-1}
    \begin{tabular}{cccccc}
        \toprule
        & & \multicolumn{4}{c}{枝の密度} \\
        & & 0.3 & 0.5 & 0.7 & 0.9 \\
        \midrule
        \multirow{6}{*}{\rotatebox{90}{節点数[個]}} 
        & 5  & \makecell{0.0016 \\ ($\pm$ 0.0019)} & \makecell{0.0023 \\ ($\pm$ 0.0020)} & \makecell{0.0023 \\ ($\pm$ 0.0003)} & \makecell{0.0025 \\ ($\pm$ 0.0010)} \\ \addlinespace
        & 7  & \makecell{0.0022 \\ ($\pm$ 0.0017)} & \makecell{0.0155 \\ ($\pm$ 0.0218)} & \makecell{0.0096 \\ ($\pm$ 0.0033)} & \makecell{0.0087 \\ ($\pm$ 0.0018)} \\ \addlinespace
        & 9  & \makecell{0.0207 \\ ($\pm$ 0.0216)} & \makecell{0.0152 \\ ($\pm$ 0.0049)} & \makecell{0.0277 \\ ($\pm$ 0.0134)} & \makecell{0.0856 \\ ($\pm$ 0.1070)} \\ \addlinespace
        & 11 & \makecell{0.0239 \\ ($\pm$ 0.0161)} & \makecell{0.0821 \\ ($\pm$ 0.0889)} & \makecell{0.8805 \\ ($\pm$ 1.8063)} & \makecell{0.7132 \\ ($\pm$ 1.4802)} \\ \addlinespace
        & 13 & \makecell{0.0528 \\ ($\pm$ 0.0235)} & \makecell{0.0703 \\ ($\pm$ 0.0236)} & \makecell{0.1718 \\ ($\pm$ 0.1475)} & \makecell{11.8041 \\ ($\pm$ 19.7397)} \\ \addlinespace
        & 15 & \makecell{0.8010 \\ ($\pm$ 1.2805)} & \makecell{4.5081 \\ ($\pm$ 9.8453)} & \makecell{464.2257 \\ ($\pm$ 1014.9181)} & \makecell{7.8398 \\ ($\pm$ 16.1049)} \\
        \bottomrule
    \end{tabular}
\end{table}

\begin{table}[htbp]
    \centering
    \caption{節点数及び枝の密度に対する探索したノード数[個]}
    \label{tab:q4-2}
    \begin{tabular}{cccccc}
        \toprule
        & & \multicolumn{4}{c}{枝の密度} \\
        & & 0.3 & 0.5 & 0.7 & 0.9 \\
        \midrule
        \multirow{6}{*}{\rotatebox{90}{節点数[個]}} 
        & 5  & \makecell{2.2 \\ ($\pm$ 0.45)} & \makecell{5.6 \\ ($\pm$ 2.30)} & \makecell{7.4 \\ ($\pm$ 1.52)} & \makecell{8.2 \\ ($\pm$ 2.59)} \\ \addlinespace
        & 7  & \makecell{6.2 \\ ($\pm$ 4.09)} & \makecell{13.6 \\ ($\pm$ 1.67)} & \makecell{17.8 \\ ($\pm$ 5.36)} & \makecell{18.6 \\ ($\pm$ 5.03)} \\ \addlinespace
        & 9  & \makecell{16.0 \\ ($\pm$ 11.00)} & \makecell{24.2 \\ ($\pm$ 6.72)} & \makecell{44.4 \\ ($\pm$ 23.35)} & \makecell{109.0 \\ ($\pm$ 120.36)} \\ \addlinespace
        & 11 & \makecell{28.2 \\ ($\pm$ 18.44)} & \makecell{85.4 \\ ($\pm$ 103.31)} & \makecell{985.2 \\ ($\pm$ 2027.30)} & \makecell{771.0 \\ ($\pm$ 1606.19)} \\ \addlinespace
        & 13 & \makecell{48.2 \\ ($\pm$ 16.66)} & \makecell{57.2 \\ ($\pm$ 23.94)} & \makecell{128.6 \\ ($\pm$ 117.02)} & \makecell{1.11 $\times 10^4$ \\ ($\pm$ 1.86 $\times 10^4$)} \\ \addlinespace
        & 15 & \makecell{552.8 \\ ($\pm$ 857.26)} & \makecell{2972.2 \\ ($\pm$ 6509.11)} & \makecell{3.27 $\times 10^5$ \\ ($\pm$ 7.13 $\times 10^5$)} & \makecell{4956.2 \\ ($\pm$ 10352.35)} \\
        \bottomrule
    \end{tabular}
\end{table}





\clearpage
\section{実行環境}
\label{sec:env}
本課題の実行環境は表\ref{tab:env}の通りである.

\begin{table}[ht]
  \centering
  \caption{実行環境}
  \label{tab:env}
  \begin{tabular}[ht]{c c}
    \hline
    OS & Ubuntu 22.04.5 LTS \\
    CPU & 13th Gen Intel(R) Core(TM) i7-1360P \\
    メモリ & 8GB \\
    使用言語 & julia 1.12.1 \\
    \hline
  \end{tabular}
\end{table}

\section{参考文献}
\label{sec:ref}
数値計算のためのコードで誤っている箇所の修正, 及びより良い書き方の勉強のため, 
Gemini 3.0 Proを使用した.


\end{document}